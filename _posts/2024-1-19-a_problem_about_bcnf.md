---
title: 一道数据库选择题和一个概念问题
author: Alex
date: 2021-01-19
category: tech
layout: post
---

## 问题来源

这是一道经典的数据库选择题：

>当关系模式R(A，B) 已属于 3NF，下列说法中()是正确的。
>
>A.它一定消除了插入和删除异常
>
>B.仍存在一定的插入和删除异常
>
>C.一定属于BCNF
>
>D.A和C都是

这道题目给出的答案是B。这引发了我的疑惑：都已经是二元关系了，为什么不一定是BCNF呢？BCNF难道不是消除了插入和删除异常吗？

## 问题分析

我去查了一下资料，发现StackOverflow上有一个很好的[回答](https://stackoverflow.com/questions/33455459/how-is-every-binary-relation-bcnf)，这里直接给出结论：

- 当不考虑对空集的函数依赖时，每个二元关系都是BCNF的
- 当考虑对空集的函数依赖时，则不一定

证明翻译如下：

>在只有两个属性A1和A2的示例中，我们有所有可能的非平凡依赖关系：
>
>1. {} -> {A1}
>
>2. {} -> {A2}
>
>3. {} -> {A1 A2}
>
>4. {A1} -> {A2}
>
>5. {A2} -> {A1}
>
>所有其他可能的依赖关系都是平凡的依赖关系，即右集是左集的子集（例如{A1} -> {}，{} -> {}，{A1} -> {A1}，{A1 A2} -> >{A1}等）。我们知道这些依赖关系总是成立的，因此它们不在正常形式的定义中考虑。
>
>当从依赖关系中排除空集时，定理成立
>
>考虑依赖关系4和5。我们有四种可能的情况：
>
>- 只有4成立，因此我们有：{A1} -> {A2}
>
>这意味着{A1}是候选键（因为从{A1} -> {A2}我们可以推导出{A1}->{A1 A2}），而BCNF条件得到满足，因为每个依赖关系都有一个超键作为决定因素；
>
>- 只有5成立，因此我们有：{A2} -> {A1}
>
>与前一种情况相同，只是A1和A2的角色交换了；
>
>- 既没有4也没有5成立（没有函数依赖关系），
>
>因此BCNF在形式上得到满足（因为没有依赖关系违反了BCNF）；
>
>最后：
>
>- 两者都成立，因此我们有{A1} -> {A2}和{A2} -> {A1}
>
>在这种情况下，关系仍然在BCNF中，因为{A1}和{A2}都是候选键，因为它，；们确定了所有属性（简单地将1和2合并）。
>
>当我们允许在函数依赖关系中使用空集时，该定理不成立
>
>- 考虑关系R（A1，A2），其依赖关系集合F为F = { {}-> {A1} }
>
>{} -> {A1}的含义，通过回顾函数依赖的定义，是A1列具有常量值。因此，我们有一个具有两列的关系，其中一个列始终具有相同的值。
>
>在这种情况下，唯一的候选键是{A2}，因为{A2}+ = {A1 A2}，其中{A1 A2}是超键，并且该关系不在BCNF中，因为非平凡的函数依赖关系（{} -> {A1}）的决定因素不是超键。

所以C是错的。不过我们还需要探究的是，这样的情况下，是否存在插入和删除异常呢？

[``Bernstein P A, Goodman N. What does Boyce-Codd normal form do?[C]//VLDB. 1980: 245-259.``](https://www.microsoft.com/en-us/research/uploads/prod/2020/12/WhatDoesBCNFdo-VLDB1980.pdf)论述了BCNF的有效性，指出在多表状况下BCNF存在问题。

那么在题目指出的情形下BCNF是否存在插入和删除异常呢？

我们也来分类讨论：

- 关系是BCNF

不存在函数依赖范围内的插入和删除异常，因为BCNF的定义就是消除了这些异常。同时也不存在非平凡的多值依赖，因而可以认为不存在任何插入和删除异常。

- 关系不是BCNF

此时，R(A1,A2)中至少一个属性是常数。这个时候是否存在插入和删除异常呢？

首先，我们给出一个插入和删除异常的定义：

- ```插入异常```:用于描述当向表中添加新行时导致不一致性的情况。

- ```删除异常```:用于描述当我们从表中删除某些行时，数据库中也会丢失任何必要的附加信息或数据的情况。

那么在有一列为常数的情况下，是否存在插入和删除异常呢？

我觉得可能是存在的。因为插入时，插入的数据可能和常数不同，导致不一致；删除时，可能丢失常数的信息。

因此，选择B是恰当的。

## 衍生问题

上面的讨论的情况可能有些特殊。但是在探究的过程中，我发现了一个比较常见的定义问题。

在我们教材《数据库系统概论（第5版）》6.2.2小节中说到：

>如果U部分函数依赖于 K，即`K-P->U`，则K称为超码 (Surpkey)。候选码是最小的超码，即K的任意一个真子集都不候选码。

显然这是自相矛盾的。对于候选码K，U完全依赖于K，而非部分依赖。因此，K-P->U是不成立的。所以候选码K不是超码。

好在这个问题在第6版中已经修正了。第6版中6.2.2小节中修正为：

>候选码和超码有什么关系呢?候选码的超集(如果存在)一定是超码，候选码的任何真子集一定不是超码。

这样逻辑就自洽了。使用第5版的朋友需要注意这个问题。

我的一位老师曾说过：

>数学就是玩概念。

虽然计算机或许更多的是工程学科，但是厘清概念也是很重要的。